1.1任务一
1.1.1启动Moveit Setup Assistant
<img width="501" height="43" alt="image" src="https://github.com/user-attachments/assets/73b2f1f2-e32c-4da9-bfee-31b603dc710d" />

图 1 启动指令

图 2 moveit配置界面
1.1.2加载机器人URDF模型（Start）

图 3 加载机器人模型
1.1.3配置自碰撞矩阵（Self-Collisions）
通过设置一定数量的随机采样点，根据这些点生成碰撞参数，检测永远不会发生碰撞的link，采用默认的采样点数量10000个。

图 4 配置碰撞矩阵
1.1.4配置虚拟关节（Virtual Joints）
虚拟关节主要用来描述机器人在world坐标系下的位置。如果机器人是移动的，则虚拟关节可以与移动基座关联，但这里设计的机械臂是固定不动的，所以无需设置虚拟关节。

图 5 配置虚拟关节
1.1.5创建规划组（Planning Groups）
首先创建机械臂本体的mainpulator组，点击“Add Group”。完成运动学解析器的配置以及运动规划算法的选择。

图 6 创建规划组
点击" Add Kin.Chain "，设置运动学计算需要包含的link。
点击界面中"Robot Links"旁的下三角，打开所有link，将机械臂的运动学计算所包含的关节设置如下：
Base Link:base_link
Tip Link:tool0

图 7 关节设置
点击save保存

图 8 完成规划组的配置
1.1.6定义机器人位姿（Robot Poses）：
设置一些自定义的位姿，比如机器人的初始位姿、制定位姿等。当使用Moveit的API编程时，可以直接通过名称调用这些位姿。
点击"Add Pose"，将机器人的初始位姿命名为"home"。

图 9 定义机械臂起始位姿
拖动设置界面的关节控制条，将机械臂改为向前状态，命名为"forward"。

图 10 定义机械臂前向位姿
两个位姿设置完成后，可以看到主界面的位姿列表。

图 11 完成机械臂位姿的定义和设置

1.1.7设置作者信息（Author Information）

图 12 设置作者信息用于接收其他使用者的反馈
1.1.8生成配置文件（Configuration Files）
点击"Browse"按钮，选择一个存储配置功能包的路径，Setup Assistant会将所有配置文件打包生成一个ROS功能包，命名为"probot_annol_moveit_config"。点击"Generate Package"按钮，如果成功生成并保存配置文件，则可以看到"Configuration package generated successfully!"的消息提示。

图 13 生成配置文件
1.1.9编译功能包并启动MoveIt

图 14 启动launch文件指令

图 15 rviz显示机械臂
1.1.10拖动规划
鼠标拖动机械臂前端，可以改变机械臂的姿态，点击"Plan&Execute"，开始规划路径，并控制机器人向目标位置移动。

图 16 拖动机械臂末端且规划并执行
1.2任务二
1.2.1关节轨迹控制器配置
在功能包下config文件夹创建.yaml文件，参数配置如下：

图 17 关节轨迹控制器参数配置
1.2.2关节状态控制器配置
在功能包下config文件夹创建.yaml文件，参数配置如下：

图 18 关节状态控制器参数配置







1.2.3MoveIt控制器配置
在MoveIt配置生成的功能包里，config文件夹中.yaml文件的参数配置如下：

图 19 MoveIt控制器参数配置
1.2.4启动launch文件并实现gazebo控制机械臂

图 20 启动gazebo的launch文件
可以看到当在rviz中控制机械臂末端运动时，gazebo中的机械臂会同步运动。

图 21 同时在rviz和gazebo中显示
1.3任务三
1.3.1初始化和配置
1.启动ROS节点：
首先初始化一个名为"moveit_fk"的ROS节点，这允许程序与ROS通信并执行后续操作。
2.启动异步旋转器：
启动一个异步旋转器`AsyncSpinner`，它允许ROS在后台处理事件，这样即使在执行阻塞操作时，ROS也能继续响应其他回调。
3.设置MoveGroupInterface
创建了一个MoveGroupInterface实例，这是MoveIt库中用于控制特定机械臂组（在这个例子中是"manipulator"）的接口。程序通过这个接口设置了关节容差、最大加速度和速度的缩放因子，这些参数能够确保机械臂精确和平滑地移动。

1.3.2移动到初始位置
回到"home"位置：程序指示机械臂移动到预定义的"home"位置，通常是机械臂的标准起始点。

图 22 初始位姿`home`
1.3.3执行目标位置移动
1.定义目标关节值：
程序定义了一组目标关节角度用弧度作为单位，这些角度代表了机械臂的目标位置（B点）。这组角度被设置为机械臂的关节目标。
2.移动到目标位置：
机械臂被控制移动到这组目标关节角度，这是通过调用`move()`函数实现的，它会使机械臂在关节空间中移动。

图 23 B点位姿

图 24 同时在gazebo和rviz中显示
1.3.4返回初始位置并结束程序
1.回到"home"位置：
机械臂完成目标位置的任务后，程序再次将机械臂移回"home"位置。这是为了确保机械臂不会在程序结束后留在一个潜在的不安全位置。
2.关闭ROS节点：
最后程序调用`ros::shutdown()`来关闭ROS节点，这会清理ROS资源，并且确保所有的ROS线程都能够退出。
1.4任务四
1.4.1初始化和配置
1.启动ROS节点：
首先初始化名为"moveit_conical"的ROS节点并启动一个异步旋转器，这允许ROS在多线程环境中运行，确保即使在执行阻塞操作时，ROS也能继续处理消息。
2.配置MoveIt接口：
接着，创建一个MoveGroupInterface实例，这是MoveIt库中的一个核心组件，用于控制特定的机械臂组（"manipulator"）。通过这个接口，程序设置了参考坐标系、允许的误差范围、最大加速度和速度。
3.准备机械臂：
程序将机械臂移动到预定义的"home"位置，这通常是一个安全的起始点，确保机械臂不会在开始执行复杂路径之前处于意外的或者可能导致碰撞的位置。

图 25 初始位姿`home`
1.4.2设置目标姿态和初始路径点
1.定义目标姿态：
程序定义了机械臂末端执行器的初始目标姿态，这个姿态通常是圆锥螺旋线的起点。
2.移动到起始位置：
机械臂被控制移动到这个初始姿态，这是螺旋线的起始点。

图 26 螺旋线初始起点
1.4.3计算螺旋线路径
1.生成螺旋线路点：
程序计算了圆锥螺旋线上的点，并将这些点作为路点添加到路径点列表中。这些点是根据螺旋线的数学参数（初始半径、高度、每圈的升高量、半径增加量和圈数）计算得出的。
2.规划路径：
使用MoveIt的`computeCartesianPath`函数，程序尝试生成一条笛卡尔（直线）路径，这条路径通过所有路点，形成机械臂末端执行器应该遵循的轨迹。程序可能需要多次尝试来找到一条成功的路径。
1.4.4计算运动并返回
1.执行螺旋线路径：
如果路径规划成功，机械臂会根据规划的路径，沿着圆锥螺旋线路径移动。

图 27 执行圆锥螺旋线
2.返回初始位置：
完成螺旋线路径后，机械臂回到"home"位置，以确保程序结束时机械臂处于已知且安全的状态。

图 26 回到`home`位姿
3.关闭ROS节点：
最后，程序关闭ROS节点，结束运行。
1.5附加任务一
1.5.1初始化配置
1.启动ROS节点：
初始化名为"moveit_attached_demo"的ROS节点, 这允许程序与ROS通信并执行后续操作。
2.配置MoveIt接口：
创建了一个MoveGroupInterface实例，这是MoveIt库中的一个核心组件，用于控制特定的机械臂组（"manipulator"）。通过此接口，程序设置了参考坐标系、允许的误差范围、最大加速度和速度。
1.5.2在场景中添加圆锥体
1.设置圆锥体的位置和四元数。
2.调用"add_cone" 函数，将圆锥体添加到场景中。

图 27 在场景中添加圆锥体
1.5.3生成螺旋线轨迹并规划执行
1.生成螺旋线轨迹：
生成指定数量的点，使用极坐标转换计算每个点在圆锥体表面的三维坐标，并将信息添加到列表中。
2.规划运动并执行：
根据上述圆锥螺旋线轨迹，规划机械臂的动作，若规划成功，则执行。

图 28 机械臂末端绕着圆锥运动
1.6附加任务二
1.6.1修改模型文件
在xacro中加入差速轮底盘与支撑轮，并将xacro文件命名为new.xacro，原机械臂文件名为probot_anno.xacro。

图 29 机械臂加入差速轮底盘与支撑轮
1.6.2初始化和配置
1.启动ROS节点：
首先初始化一个名为mobile_arm_control的ROS节点。
2.配置MoveIt接口：
创建moveit_commander.RobotCommander对象，获取整个机器人的信息；创建moveit_commander.PlanningSceneInterface对象，用于与场景进行交互；创建moveit_commander.MoveGroupCommander对象，控制名为"manipulator"的机械臂组。
3.初始化tf2监听器：
初始化tf2_ros.Buffer和tf2_ros.TransformListener对象，用于处理坐标变换。
1.6.3设置目标姿态和初始路径点
1.定义目标姿态：
定义一个全局的target_pose变量，指定了机械臂末端执行器的目标位姿。

图 30 odom坐标系下初始化目标位姿
2.订阅里程计数据：
订阅/odom主题，以获取机器人底盘的里程计数据，并在回调函数中处理。
1.6.4主循环执行
1.发布底盘速度指令：
在主循环中，脚本周期性地发布 Twist 消息到 /cmd_vel 主题，以控制机器人底盘进行直线或转弯运动。
(1)底盘进行直线运动时

图 31 底盘直线运动(1)

图 32 底盘直线运动(2)

图 34 机械臂末端位姿始终保持不变
(2)底盘进行转弯时

图 35 底盘转弯运动(1)

图 33 底盘转弯运动(2)

图 34 机械臂末端位姿始终保持不变
2.机械臂运动规划和执行：
同时，脚本设置机械臂的速度缩放因子，并指示机械臂规划并执行到目标姿态的运动。
1.6.5处理里程计数据和坐标变换
1.回调函数：
在 odom_callback 函数中，脚本等待并获取从 odom 到 base_link 的坐标变换。
2.转换目标姿态：
将定义的目标姿态从 odom 坐标系转换到 base_link 坐标系。
3.更新机械臂目标位姿：
脚本更新 MoveGroupCommander 对象的目标位姿，并指示机械臂进行运动规划和执行。
1.6.6关闭ROS节点
在主循环结束后，脚本关闭ROS节点和moveit_commander来结束程序运行。
